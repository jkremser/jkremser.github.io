<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Jirka Kremser</title><link>https://jkremser.github.io/post/</link><description>Recent content in Posts on Jirka Kremser</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 08 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://jkremser.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>IP Address Management for Cluster API &amp; on-prem</title><link>https://jkremser.github.io/post/ipam-for-capv/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate><guid>https://jkremser.github.io/post/ipam-for-capv/</guid><description>Motivation Cluster API (CAPI) provides a uniform workflow for deploying and operating Kubernetes clusters. It aims to abstract its user from the infrastructure level. The infrastructure in the form of VMs can be provided by a cloud provider like AWS or Azure. However, these platforms often support also managed Kubernetes experience (EKS, AKS), where a lot of features like load balancing or managed control planes are just there.</description></item><item><title>Prototyping a web app that can talk to Kubernetes API</title><link>https://jkremser.github.io/post/web-app-kubernetes/</link><pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate><guid>https://jkremser.github.io/post/web-app-kubernetes/</guid><description>Motivation With the advent of various types of operators on top of Kubernetes platform, it might be useful to provide users with a fancy dashboard. However, dashboards these days are often written in JavaScript and libraries/frameworks like React.js, Vue.js or Angular. Kubernetes API on the other hand is a bunch of REST endpoints. So it all may look pretty simple, just call those endpoints from the app written in JavaScript, right?</description></item><item><title>Migrating the Spark Operator to Quarkus</title><link>https://jkremser.github.io/post/spark-operator-quarkus/</link><pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate><guid>https://jkremser.github.io/post/spark-operator-quarkus/</guid><description>Spark Operator ‚ù§ Quarkus This attempts to describe the migration path of Spark Operator from the conventional (hotspot) JVM to quarkus.io / GraalVM.
Why Applications written in Java that run on JVM are often long running in nature, and optimized for the peek performance. JVM maintains the counters of the method invocations and has also other ways to figure out what the hot paths in the byte code are.</description></item></channel></rss>